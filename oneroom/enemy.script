local broadcast = require "ludobits.m.broadcast"


go.property("speed", 25)

local CONTACT_POINT_RESPONSE = hash("contact_point_response")
local COLLISION_RESPONSE = hash("collision_response")
local WALL = hash("wall")
local BULLET = hash("bullet")

local PLAYER_DEAD = hash("player_dead")


local NORTH = vmath.vector3(0, 1, 0)

function init(self)
	self.correction = vmath.vector3()
	broadcast.register("player_dead")
end

function final(self)
	broadcast.unregister("player_dead")
end

function update(self, dt)
	local player_pos = go.get_position("player")
	local my_pos = go.get_position()
	local target_angle = -math.atan2(player_pos.x - my_pos.x, player_pos.y - my_pos.y)
	local target_quat = vmath.quat_rotation_z(target_angle)
	go.set_position(my_pos + self.correction + vmath.rotate(target_quat, NORTH) * self.speed * dt)
	
	--print(self.correction)
	self.correction = vmath.vector3()
end

function on_message(self, message_id, message, sender)
	if message_id == CONTACT_POINT_RESPONSE then
		if message.group == WALL then
			local proj = vmath.dot(self.correction, message.normal)
			local comp = (message.distance - proj) * message.normal
			self.correction = self.correction + comp
			go.set_position(go.get_position() + comp * 1)
			--pprint(message)
			--go.set_position(go.get_position() + (message.normal * message.distance * 1))
		end
	elseif message_id == COLLISION_RESPONSE then
		if message.group == BULLET then
			go.delete()
			local random = math.random(1,100)
			if random > 90 then
				msg.post("game", "spawn_weapon", { position = go.get_position() })
			elseif random > 75 then
				msg.post("game", "spawn_ammo", { position = go.get_position() })
			end
		end
	elseif message_id == PLAYER_DEAD then
		go.delete()
	end
end

function on_input(self, action_id, action)
    -- Add input-handling code here
    -- Remove this function if not needed
end

function on_reload(self)
    -- Add reload-handling code here
    -- Remove this function if not needed
end
